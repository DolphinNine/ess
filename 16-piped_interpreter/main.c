/*Основная программа интерпретатора*/
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <linux/limits.h>
/*
В limits.h определён максимальный размер ввода и пути
#define ARG_MAX 131072
#define PATH_MAX 4096
*/
int main()
{
  char cwd[PATH_MAX] = {0};
  char command[ARG_MAX] = {0};
  char *arg_list1[100] = {0}, *arg_list2[100] = {0};
  char *char_position, *token;
  char args_amount = '1';
  pid_t pid[2];
  int i;
  int fd[2];

  printf("Piped interpreter\n"\
          "Type 'quit' to exit\n\n");

  /*Бесконечный цикл, прерываемый только по вводу строки "quit"*/
  while (1)
  {
    getcwd(cwd, PATH_MAX); /*Считать текущую директорию*/
    printf("%s> ", cwd); /*Вывести текущую директорию*/
    fgets(command, ARG_MAX, stdin); /*Ожидание строки с командой*/

    /*fgets запишет в строку все символы, включая '\n'. Что далее в программе
      не учитывать его наличие, лучше сразу от него избавиться*/
    char_position = strchr(command, '\n'); /*Найти символ*/
    *char_position = '\0'; /*Заменить на конец строки*/

    /*В первую очередь проверяется, не команда ли это выхода из программы*/
    if(strcmp(command, "quit") == 0)
    {
      printf("Quiting...\n");
      exit(0);
    }
    /*Ввод одиночного Enter приводит к вылету. Если это был он, то сейчас
      на нулевой позиции буфера команды находится '\0'. Если это так - уйти
      не следующую итерацию цикла(по сути, начав всё сначала)*/
    if(command[0] == '\0')
    {
      continue;
    }

    /*Если не собственная команда выхода из программы - то это любая другая
      утилита системы, что обрабатывается далее*/

/*----------------------------------------------------------------------------*/
/*Разделение аргументов считанной команды*/

    /*Разбиение команды на два списка аргументов, которые будут двумя разными
      вызовами утилит. До '|' - первый вызов, после '|' - второй* вызов*/
    /*Хотя первый вызов strtok в таком написании, вроде как, должен возвращать
      NULL, вместо этого он возвращает указатель на саму строку. Значит
      первый вызов в любом случае вернёт саму строку, даже если там нет
      розыскиваемого символа*/
    if ((*arg_list1 = strtok(command, "|")) != NULL)
    {
      /*Сейчас ещё не известно, сколько вызовов. По-умолчанию считается, что один*/
      args_amount = '1';

      /*Продолжать идти по строке(NULL указывает на продолжение ранее переданой)*/
      token = (strtok(NULL, "|"));
      /*Теперь, если символа действительно нет, будет возвращён NULL*/
      if(token != NULL)
      {
        /*Токен сдвигается на единицу далее. Так он будет указывать не на
          пробел, который следует за чертой '|', а на символ после него*/
        token++;
        *arg_list2 = token;
        args_amount = '2';
      }
    }

    /*Работа с аргументами первой команды*/
    char_position = *arg_list1; /*Указатель на текущий символ*/
    i = 1;
    /*Цикл выполняется, пока не дойдёт до символа конца строки. Он был помещён
    в строку ранее.*/
    while (*char_position != '\0')
    {
      /*Если это пробел, значит был найден новый аргумент*/
     if ((*char_position == ' ') && (((*char_position) + 1) != ' '))
     {
       *char_position = '\0'; /*Разделить аргументы*/
       arg_list1[i] = char_position + 1; /*Запомнить адресс следующего аргумента*/
       i++;
     }
     char_position++; /*Продолжить движение по символам*/
    }

    /*Работа с аргументами второй команды*/
    if (args_amount == '2')
    {
      /*Адрес последнего символа первого вектора сейчас указывает на '\0'. Чтобы
        он не считался частью команды, адресс этого символа в векторе просто
        зануляется, после чего он не будет учитываться дальнейшими вызовами*/
      arg_list1[i - 1] = NULL;
      /*Остальной процесс работы идентичен обработке первого вектора*/
      char_position = *arg_list2;
      i = 1;
      while (*char_position != '\0')
      {
        if (*char_position == ' ')
        {
          *char_position = '\0';
          arg_list2[i] = char_position + 1;
          i++;
        }
        char_position++;
      }
      /*Так как известно, что команды две - создаётся pipe для будущих задач*/
      pipe(fd);
    }

/*----------------------------------------------------------------------------*/
/*Запуски утилит*/

    /*Основная и, возможно, единственная команда*/
    if((pid[0] = fork()) == 0)
    {
      /*Если команды две, нужно дополнительно поработать с pipe-ами*/
      if (args_amount == '2')
      {
        while(dup2(fd[1], 1) == -1) {} /*Подменить поток вывода на pipe*/
        /*После дубликации, потоки пайпа можно закрыть - программа всё равно
          о них не будет знать, так как уверена, что пользуется стандартными
          потоками ввода/вывода*/
        close(fd[0]);
        close(fd[1]);
      }
      /*'p' - вызов сам будет искать утилиты в стандартных системных папках -
        не придётся получать эти директории в ручную
        'v' - аргументы передаются вектором. Он был сформирован ранее.
        "*arg_list1" - указывает на первый(нулевой) аргумент вектора - саму
        утилиту.
        "arg_list1" - указывает на вектор в целом. Все ключи программы в нём
        разделены \0, на что и расчитывает вызов exec*/
      if(execvp(*arg_list1, arg_list1) == -1)
      {
        /*Если произойдёт ошибка - программа просто сообщит о ней и продолжит
          работу по циклу. Дочерний процесс завершится.*/
        perror("EXECUTION_1: ");
        return -1;
      }
    }
    /*Второй вектор используется, если установлено, что и команды будет две*/
    if(args_amount == '2')
    {
      if((pid[1] = fork()) == 0)
      {
        while(dup2(fd[0], 0) == -1) {} /*Подменить поток ввода на pipe*/
        close(fd[0]);
        close(fd[1]);
        if(execvp(*arg_list2, arg_list2) == -1)
        {
          perror("EXECUTION_2: ");
          return -1;
        }
      }
    }

    /*Ожидание конца работы дочерних процессов*/
    waitpid(pid[0], NULL, WUNTRACED);
    /*Есть редкие баги связанные с остаточным мусором. Для их исключения
      массивы зачищяются*/
    memset(arg_list1, 0, sizeof(arg_list1));
    if(args_amount == '2')
    {
      waitpid(pid[1], NULL, WNOHANG);
      memset(arg_list2, 0, sizeof(arg_list2));
      close(fd[0]);
      close(fd[1]);
    }
  }
}
