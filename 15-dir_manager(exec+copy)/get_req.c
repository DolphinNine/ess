/*Забор содержимого директории*/
#include <curses.h>
#include <string.h>
#include <stdlib.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>
#include <magic.h> /*Потребуется библиотека libmagic*/
#include "proto.h"

struct dirent **get_req(WINDOW * wnd, struct dirent **dir_entry, int *entries_amount_ptr, int *relative_y_ptr, char req_name[256]) /*Получает имя директории*/
{
  int mx_std, my_std, my, mx; /*Хранение размеров основного окна*/
  struct dirent **dir_entry_income = dir_entry; /*Запоминание входящей структуры*/
  int entries_amount = *entries_amount_ptr; /*Запоминание входящего числа записей*/

  getmaxyx(wnd, my, mx); /*Заранее запрашиваются макс.размеры окна */

/*----------------------------------------------------------------------------*/
/*Первое, что предполагает программа, это то, что перенаданное имя - директория.
  Именно это она проверяет через scandir в первую очередь.*/

  /*Используется scandir для вывода именён в нужном порядке(по алфавиту).
  Так '.' и '..' будут идти раньше всех*/
  if ((entries_amount = scandir(req_name, &dir_entry, NULL, alphasort)) == -1)
  {
    /*-1 - ошибка отрытия директории, но может это и не она?*/
    if (errno == ENOTDIR) /*Это не директория?*/
    {

/*----------------------------------------------------------------------------*/
/*Сработала ошибка. Если это ошибка указывает на то, что открыть пытались
  НЕ директорию, то стоит проверить, что это было.*/

      /*Возможно, это исполняемый файл?*/
      char type[256]; /*Хранение информации о типе(не расширении)*/
      const char *file; /*Указатель на данные от magic_file*/
      /*Создаётся magic cookie - фильтр(маска) вывода информации о файле*/
      magic_t mag = magic_open(MAGIC_MIME | MAGIC_NO_CHECK_ELF);
      magic_load(mag, NULL); /*Фильтр загружается*/
      file = magic_file(mag, req_name); /*Проверить файл, применяя фильтр*/
      /*Цикл поиска символа, информация после которого уже не имеет значения
        для программы*/
      for (int i = 0; i < 256; i++)
      {
        if(file[i] == '/') /*Это символ слэша*/
        {
          break; /*Символ найден - выйти из цикла*/
        }
        type[i] = file[i]; /*Посимвольный перенос нужной информации в char массив*/
      }
      /*Если это исполняемый файл приложения, то информация до слэша будет
        гласить "application". Иначе, там может быть что угодно, например
        "text".*/
      if(strcmp(type, "application") == 0) /*Это исполняемый файл?*/
      {

/*----------------------------------------------------------------------------*/
/*Это действительно исполняемый файл. Теперь программа попытается его открыть*/

        /*Если исполняемый - создаётся дочерний процесс*/
        pid_t pid;
        magic_close(mag); /*"Закрыть" фильтр*/
        /*Для восстановленя контекста окна после исполнения файла требуется
          сохранить это окно. Сейчас используется помещение данных об окне в
          файл. Далее, когда работа и выделенным исполняемым файлом будет
          окончена, контекст окна будет восстановлен из этого же файла.
          (возможно, будет лучше сделать это потом на каналах, вместо файлов)*/
        scr_dump("/tmp/source.wnd"); /*Создать файла в папке tmp*/
        endwin(); /*Закрыть окно*/
        printf("\n-----Left manager programm-----\n\n");
        if ((pid = fork()) == 0)
        {
          /*В дочернем процессе подменяется код на исполняемый файл открытого
            файла*/
          /*Запуск неудался - выйти (будет лучше переписать на сообщение
            о невозможости открытия, без закрытия программы в целом)*/
          if(execl(req_name, req_name, NULL) == -1)
          {
            perror("Unable to start process\n");
            quit(dir_entry, entries_amount_ptr, -1);
          }
        }
        /*Ожидание конца работы открытого исполянемого файла*/
        waitpid(pid, NULL, WUNTRACED);
        printf("\n-----App executed-----\n"\
                "Press any key to return\n");
        getch(); /*Ожидание нажатия клавиши. Иначе окно появится мгновенно.*/
        scr_restore("/tmp/source.wnd"); /*Восстановить окно из файла*/
        doupdate(); /*Обновить экран*/
        return dir_entry_income; /*Возврат изначальной структуры*/
      }

/*----------------------------------------------------------------------------*/
/*Функция не окончилась ранее, значит, это не исполняемый файл. Теперь это либо
  директория, либо сработала иная ошибка*/

      /*Не директория*/
      print_message(wnd, -1, "GET REQUEST: Not a directory!");
      // attron(COLOR_PAIR(3)); /*Использовать красный цвет выделения текста*/
      // getmaxyx(stdscr, my_std, mx_std);
      // mvprintw(my_std-1, 2, "NOT A DIRECTORY!"); /*Сообщить об этом на дне главного окна*/
      // refresh();
      // attron(COLOR_PAIR(2)); /*Вернуть цвет*/
      /*Нет смысла выводить НЕ директорию. Преждевременный выход из функции*/
      return dir_entry_income; /*Возврат изначальной структуры*/
    }
    /*Если это иная ошибка - выйти из программы*/
    endwin();
    perror("Unable to scan the directory stream!");
    quit(dir_entry, entries_amount_ptr, -1);
  }

/*----------------------------------------------------------------------------*/
/*Фунция не была окончена ранее - значит, это точно директория. Она была без
  ошибок проканирована и теперь её данные хранятся в структуре, переданной
  scandir*/

/*Заполнение relative_y переехало в эту функцию из main. Это позволило избежать
  перезаписи переменной в случаее, если директория не была сменена*/

  /*Чтобы после скроллинга не потерять записи выше или ниже экрана -
  вводится относительная позиция для строк*/
  /*Отн.позиция, по сути, будет указывать на то, сколько записей под "потолком" экрана
  или под его "полом", и будет модифицировать значение строки, для того,
  чтобы корректно потом получить номер записи в структуре директории*/
  if (entries_amount > my) /*Если кол-во записей больше того, что вмещает экран*/
  {
    *relative_y_ptr = entries_amount - my + 1; /*Записать остатки в относительную позицию*/
  }
  else
  {
    *relative_y_ptr = 0;
  }
  /*Вывод имён содержимого директории*/
   werase(wnd);
   wmove(wnd, 0, 0);
   for (int i = 0; i < entries_amount; i++)
   {
     /*Если '.' или '..' - вывести описание их работы, а не точки*/
     if (strcmp(dir_entry[i]->d_name, ".") == 0)
     {
       wprintw(wnd, "/[CURRENT DIR]\n");
       continue;
     }
     if (strcmp(dir_entry[i]->d_name, "..") == 0)
     {
       wprintw(wnd, "/[PARENT DIR]\n");
       continue;
     }
     /*Иначе - просто вывести с пробелом перед именем*/
     wprintw(wnd, " %s\n", dir_entry[i]->d_name);
   }
   /*Дейсвтия ранее привели к коректному открытию новой директории, значит
    можно передать новые значения структуры и числа записей в директории*/
  *entries_amount_ptr = entries_amount;
  return dir_entry;
}
